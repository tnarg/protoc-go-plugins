package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
)

var (
	outputTmpl = template.Must(template.New("output_file").Parse(templateStr))
)

const templateStr = `
// Code generated by protoc-gen-servertesting. DO NOT EDIT.
// source: {{.Source}}

package {{.Package}}

import (
	"context"
	"google.golang.org/grpc"
)

{{range .Services}}
type {{.TestService}} struct {
	Underlying {{.Service}}
	Interceptor *grpc.UnaryServerInterceptor
}

{{range .Methods}}
func (_s {{.TestService}}) {{.Method}}(ctx context.Context, req {{.RequestType}}) ({{.ResponseType}}, error) {
	if _s.Interceptor != nil {
		interceptorF := *_s.Interceptor
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return _s.Underlying.{{.Method}}(ctx, req.({{.RequestType}}))
		}
		resp, err := interceptorF(ctx, req, nil, handler)
		if resp != nil {
			return resp.({{.ResponseType}}), err
		}
		return nil, err
	}
	return _s.Underlying.{{.Method}}(ctx, req)
}
{{end}}
{{end}}
`

type templateInfo struct {
	Source   string
	Package  string
	Services []*templateServiceInfo
}

type templateServiceInfo struct {
	Service     string
	TestService string
	Methods     []*templateMethodInfo
}

type templateMethodInfo struct {
	TestService  string
	Method       string
	RequestType  string
	ResponseType string
}

func outputName(file string) string {
	ext := filepath.Ext(file)
	base := strings.TrimSuffix(file, ext)
	return fmt.Sprintf("%s.servertesting.pb.go", base)
}

// defaultGoPackageName returns the default go package name to be used for go files generated from "f".
// You might need to use an unique alias for the package when you import it.  Use ReserveGoPackageAlias to get a unique alias.
func defaultGoPackageName(f *descriptor.FileDescriptorProto) string {
	name := packageIdentityName(f)
	return sanitizePackageName(name)
}

// sanitizePackageName replaces unallowed character in package name
// with allowed character.
func sanitizePackageName(pkgName string) string {
	pkgName = strings.Replace(pkgName, ".", "_", -1)
	pkgName = strings.Replace(pkgName, "-", "_", -1)
	return pkgName
}

// packageIdentityName returns the identity of packages.
// protoc-gen-grpc-gateway rejects CodeGenerationRequests which contains more than one packages
// as protoc-gen-go does.
func packageIdentityName(f *descriptor.FileDescriptorProto) string {
	if f.Options != nil && f.Options.GoPackage != nil {
		gopkg := f.Options.GetGoPackage()
		idx := strings.LastIndex(gopkg, "/")
		if idx < 0 {
			gopkg = gopkg[idx+1:]
		}

		gopkg = gopkg[idx+1:]
		// package name is overrided with the string after the
		// ';' character
		sc := strings.IndexByte(gopkg, ';')
		if sc < 0 {
			return sanitizePackageName(gopkg)

		}
		return sanitizePackageName(gopkg[sc+1:])
	}

	if f.Package == nil {
		base := filepath.Base(f.GetName())
		ext := filepath.Ext(base)
		return strings.TrimSuffix(base, ext)
	}
	return f.GetPackage()
}

func messageType(in string) string {
	spl := strings.Split(in, ".")
	return fmt.Sprintf("*%s", spl[len(spl)-1])
}

func generateCode(file *descriptor.FileDescriptorProto) (string, error) {
	buffer := &bytes.Buffer{}
	info := &templateInfo{
		Source:   file.GetName(),
		Package:  defaultGoPackageName(file),
		Services: make([]*templateServiceInfo, len(file.GetService())),
	}
	for si, service := range file.GetService() {
		name := service.GetName()
		testName := fmt.Sprintf("Test%s", name)
		info.Services[si] = &templateServiceInfo{
			Service:     fmt.Sprintf("%sServer", name),
			TestService: testName,
			Methods:     make([]*templateMethodInfo, len(service.GetMethod())),
		}
		srv := info.Services[si]
		for mi, method := range service.GetMethod() {
			srv.Methods[mi] = &templateMethodInfo{
				TestService:  testName,
				Method:       method.GetName(),
				RequestType:  messageType(method.GetInputType()),
				ResponseType: messageType(method.GetOutputType()),
			}
		}
	}
	if err := outputTmpl.Execute(buffer, info); err != nil {
		return "", err
	}
	return buffer.String(), nil
}

func generate(req *plugin.CodeGeneratorRequest) ([]*plugin.CodeGeneratorResponse_File, error) {
	var files []*plugin.CodeGeneratorResponse_File
	genFileNames := make(map[string]bool)
	for _, n := range req.FileToGenerate {
		genFileNames[n] = true
	}

	for _, file := range req.GetProtoFile() {
		filename := file.GetName()
		if _, ok := genFileNames[filename]; !ok {
			// Only emit output for files present in req.FileToGenerate.
			continue
		}

		code, err := generateCode(file)
		if err != nil {
			return nil, err
		}
		formatted, err := format.Source([]byte(code))
		if err != nil {
			log.Printf("%v: %s", err, code)
			return nil, err
		}

		output := outputName(filename)
		files = append(files, &plugin.CodeGeneratorResponse_File{
			Name:    proto.String(output),
			Content: proto.String(string(formatted)),
		})
	}

	return files, nil
}

func emitFiles(out []*plugin.CodeGeneratorResponse_File) {
	emitResp(&plugin.CodeGeneratorResponse{File: out})
}

func emitError(err error) {
	emitResp(&plugin.CodeGeneratorResponse{Error: proto.String(err.Error())})
}

func emitResp(resp *plugin.CodeGeneratorResponse) {
	buf, err := proto.Marshal(resp)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := os.Stdout.Write(buf); err != nil {
		log.Fatal(err)
	}
}

func main() {
	input, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		log.Fatal(err)
	}

	req := new(plugin.CodeGeneratorRequest)
	if err = proto.Unmarshal(input, req); err != nil {
		log.Fatal(err)
	}

	out, err := generate(req)
	if err != nil {
		emitError(err)
	} else {
		emitFiles(out)
	}
}
